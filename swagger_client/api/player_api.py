# coding: utf-8

"""
    Spotify Web API

    You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers.   # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class PlayerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_to_queue(self, uri, **kwargs):  # noqa: E501
        """Add Item to Playback Queue   # noqa: E501

        Add an item to the end of the user's current playback queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_queue(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_to_queue_with_http_info(uri, **kwargs)  # noqa: E501
        else:
            (data) = self.add_to_queue_with_http_info(uri, **kwargs)  # noqa: E501
            return data

    def add_to_queue_with_http_info(self, uri, **kwargs):  # noqa: E501
        """Add Item to Playback Queue   # noqa: E501

        Add an item to the end of the user's current playback queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_queue_with_http_info(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uri', 'device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_to_queue" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `add_to_queue`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'uri' in params:
            query_params.append(('uri', params['uri']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/queue', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_a_users_available_devices(self, **kwargs):  # noqa: E501
        """Get Available Devices   # noqa: E501

        Get information about a user’s available devices.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_a_users_available_devices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_a_users_available_devices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_a_users_available_devices_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_a_users_available_devices_with_http_info(self, **kwargs):  # noqa: E501
        """Get Available Devices   # noqa: E501

        Get information about a user’s available devices.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_a_users_available_devices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_a_users_available_devices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_information_about_the_users_current_playback(self, **kwargs):  # noqa: E501
        """Get Playback State   # noqa: E501

        Get information about the user’s current playback state, including track or episode, progress, and active device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_information_about_the_users_current_playback(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str market:
        :param str additional_types:
        :return: CurrentlyPlayingContextObject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_information_about_the_users_current_playback_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_information_about_the_users_current_playback_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_information_about_the_users_current_playback_with_http_info(self, **kwargs):  # noqa: E501
        """Get Playback State   # noqa: E501

        Get information about the user’s current playback state, including track or episode, progress, and active device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_information_about_the_users_current_playback_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str market:
        :param str additional_types:
        :return: CurrentlyPlayingContextObject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['market', 'additional_types']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_information_about_the_users_current_playback" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'market' in params:
            query_params.append(('market', params['market']))  # noqa: E501
        if 'additional_types' in params:
            query_params.append(('additional_types', params['additional_types']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CurrentlyPlayingContextObject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_queue(self, **kwargs):  # noqa: E501
        """Get the User's Queue   # noqa: E501

        Get the list of objects that make up the user's queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_queue(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: QueueObject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_queue_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_queue_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_queue_with_http_info(self, **kwargs):  # noqa: E501
        """Get the User's Queue   # noqa: E501

        Get the list of objects that make up the user's queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_queue_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: QueueObject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_queue" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/queue', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueueObject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recently_played(self, **kwargs):  # noqa: E501
        """Get Recently Played Tracks   # noqa: E501

        Get tracks from the current user's recently played tracks. _**Note**: Currently doesn't support podcast episodes._   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recently_played(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit:
        :param int after:
        :param int before:
        :return: CursorPagingPlayHistoryObject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recently_played_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_recently_played_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_recently_played_with_http_info(self, **kwargs):  # noqa: E501
        """Get Recently Played Tracks   # noqa: E501

        Get tracks from the current user's recently played tracks. _**Note**: Currently doesn't support podcast episodes._   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recently_played_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit:
        :param int after:
        :param int before:
        :return: CursorPagingPlayHistoryObject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'after', 'before']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recently_played" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/recently-played', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CursorPagingPlayHistoryObject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_the_users_currently_playing_track(self, **kwargs):  # noqa: E501
        """Get Currently Playing Track   # noqa: E501

        Get the object currently being played on the user's Spotify account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_the_users_currently_playing_track(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str market:
        :param str additional_types:
        :return: CurrentlyPlayingContextObject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_the_users_currently_playing_track_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_the_users_currently_playing_track_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_the_users_currently_playing_track_with_http_info(self, **kwargs):  # noqa: E501
        """Get Currently Playing Track   # noqa: E501

        Get the object currently being played on the user's Spotify account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_the_users_currently_playing_track_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str market:
        :param str additional_types:
        :return: CurrentlyPlayingContextObject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['market', 'additional_types']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_the_users_currently_playing_track" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'market' in params:
            query_params.append(('market', params['market']))  # noqa: E501
        if 'additional_types' in params:
            query_params.append(('additional_types', params['additional_types']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/currently-playing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CurrentlyPlayingContextObject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_a_users_playback(self, **kwargs):  # noqa: E501
        """Pause Playback   # noqa: E501

        Pause playback on the user's account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_a_users_playback(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pause_a_users_playback_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pause_a_users_playback_with_http_info(**kwargs)  # noqa: E501
            return data

    def pause_a_users_playback_with_http_info(self, **kwargs):  # noqa: E501
        """Pause Playback   # noqa: E501

        Pause playback on the user's account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_a_users_playback_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_a_users_playback" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/pause', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def seek_to_position_in_currently_playing_track(self, position_ms, **kwargs):  # noqa: E501
        """Seek To Position   # noqa: E501

        Seeks to the given position in the user’s currently playing track.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.seek_to_position_in_currently_playing_track(position_ms, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int position_ms: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.seek_to_position_in_currently_playing_track_with_http_info(position_ms, **kwargs)  # noqa: E501
        else:
            (data) = self.seek_to_position_in_currently_playing_track_with_http_info(position_ms, **kwargs)  # noqa: E501
            return data

    def seek_to_position_in_currently_playing_track_with_http_info(self, position_ms, **kwargs):  # noqa: E501
        """Seek To Position   # noqa: E501

        Seeks to the given position in the user’s currently playing track.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.seek_to_position_in_currently_playing_track_with_http_info(position_ms, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int position_ms: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['position_ms', 'device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method seek_to_position_in_currently_playing_track" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'position_ms' is set
        if ('position_ms' not in params or
                params['position_ms'] is None):
            raise ValueError("Missing the required parameter `position_ms` when calling `seek_to_position_in_currently_playing_track`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'position_ms' in params:
            query_params.append(('position_ms', params['position_ms']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/seek', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_repeat_mode_on_users_playback(self, state, **kwargs):  # noqa: E501
        """Set Repeat Mode   # noqa: E501

        Set the repeat mode for the user's playback. Options are repeat-track, repeat-context, and off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_repeat_mode_on_users_playback(state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str state: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_repeat_mode_on_users_playback_with_http_info(state, **kwargs)  # noqa: E501
        else:
            (data) = self.set_repeat_mode_on_users_playback_with_http_info(state, **kwargs)  # noqa: E501
            return data

    def set_repeat_mode_on_users_playback_with_http_info(self, state, **kwargs):  # noqa: E501
        """Set Repeat Mode   # noqa: E501

        Set the repeat mode for the user's playback. Options are repeat-track, repeat-context, and off.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_repeat_mode_on_users_playback_with_http_info(state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str state: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['state', 'device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_repeat_mode_on_users_playback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'state' is set
        if ('state' not in params or
                params['state'] is None):
            raise ValueError("Missing the required parameter `state` when calling `set_repeat_mode_on_users_playback`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/repeat', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_volume_for_users_playback(self, volume_percent, **kwargs):  # noqa: E501
        """Set Playback Volume   # noqa: E501

        Set the volume for the user’s current playback device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_volume_for_users_playback(volume_percent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int volume_percent: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_volume_for_users_playback_with_http_info(volume_percent, **kwargs)  # noqa: E501
        else:
            (data) = self.set_volume_for_users_playback_with_http_info(volume_percent, **kwargs)  # noqa: E501
            return data

    def set_volume_for_users_playback_with_http_info(self, volume_percent, **kwargs):  # noqa: E501
        """Set Playback Volume   # noqa: E501

        Set the volume for the user’s current playback device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_volume_for_users_playback_with_http_info(volume_percent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int volume_percent: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['volume_percent', 'device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_volume_for_users_playback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'volume_percent' is set
        if ('volume_percent' not in params or
                params['volume_percent'] is None):
            raise ValueError("Missing the required parameter `volume_percent` when calling `set_volume_for_users_playback`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'volume_percent' in params:
            query_params.append(('volume_percent', params['volume_percent']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/volume', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def skip_users_playback_to_next_track(self, **kwargs):  # noqa: E501
        """Skip To Next   # noqa: E501

        Skips to next track in the user’s queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.skip_users_playback_to_next_track(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.skip_users_playback_to_next_track_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.skip_users_playback_to_next_track_with_http_info(**kwargs)  # noqa: E501
            return data

    def skip_users_playback_to_next_track_with_http_info(self, **kwargs):  # noqa: E501
        """Skip To Next   # noqa: E501

        Skips to next track in the user’s queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.skip_users_playback_to_next_track_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method skip_users_playback_to_next_track" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/next', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def skip_users_playback_to_previous_track(self, **kwargs):  # noqa: E501
        """Skip To Previous   # noqa: E501

        Skips to previous track in the user’s queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.skip_users_playback_to_previous_track(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.skip_users_playback_to_previous_track_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.skip_users_playback_to_previous_track_with_http_info(**kwargs)  # noqa: E501
            return data

    def skip_users_playback_to_previous_track_with_http_info(self, **kwargs):  # noqa: E501
        """Skip To Previous   # noqa: E501

        Skips to previous track in the user’s queue.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.skip_users_playback_to_previous_track_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method skip_users_playback_to_previous_track" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/previous', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_a_users_playback(self, **kwargs):  # noqa: E501
        """Start/Resume Playback   # noqa: E501

        Start a new context or resume current playback on the user's active device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_a_users_playback(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body:
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_a_users_playback_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.start_a_users_playback_with_http_info(**kwargs)  # noqa: E501
            return data

    def start_a_users_playback_with_http_info(self, **kwargs):  # noqa: E501
        """Start/Resume Playback   # noqa: E501

        Start a new context or resume current playback on the user's active device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_a_users_playback_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body:
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_a_users_playback" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/play', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def toggle_shuffle_for_users_playback(self, state, **kwargs):  # noqa: E501
        """Toggle Playback Shuffle   # noqa: E501

        Toggle shuffle on or off for user’s playback.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_shuffle_for_users_playback(state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool state: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.toggle_shuffle_for_users_playback_with_http_info(state, **kwargs)  # noqa: E501
        else:
            (data) = self.toggle_shuffle_for_users_playback_with_http_info(state, **kwargs)  # noqa: E501
            return data

    def toggle_shuffle_for_users_playback_with_http_info(self, state, **kwargs):  # noqa: E501
        """Toggle Playback Shuffle   # noqa: E501

        Toggle shuffle on or off for user’s playback.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toggle_shuffle_for_users_playback_with_http_info(state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool state: (required)
        :param str device_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['state', 'device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method toggle_shuffle_for_users_playback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'state' is set
        if ('state' not in params or
                params['state'] is None):
            raise ValueError("Missing the required parameter `state` when calling `toggle_shuffle_for_users_playback`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'device_id' in params:
            query_params.append(('device_id', params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player/shuffle', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transfer_a_users_playback(self, **kwargs):  # noqa: E501
        """Transfer Playback   # noqa: E501

        Transfer playback to a new device and determine if it should start playing.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transfer_a_users_playback(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.transfer_a_users_playback_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.transfer_a_users_playback_with_http_info(**kwargs)  # noqa: E501
            return data

    def transfer_a_users_playback_with_http_info(self, **kwargs):  # noqa: E501
        """Transfer Playback   # noqa: E501

        Transfer playback to a new device and determine if it should start playing.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transfer_a_users_playback_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, object) body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transfer_a_users_playback" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth_2_0']  # noqa: E501

        return self.api_client.call_api(
            '/me/player', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
